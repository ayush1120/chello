import asyncio
import os
from typing import Dict, Any, AsyncGenerator

# Set API key if not in environment
if "GOOGLE_API_KEY" not in os.environ:
    os.environ["GOOGLE_API_KEY"] = "AIzaSyDYnzqyVrwldM3jrBHKOsytV-yGr-Wg9XU"

from google.adk.agents import BaseAgent, LlmAgent, InvocationContext
from google.adk.models import BaseLlm
from google.adk.models import Gemini
from google.adk.tools import ToolContext, FunctionTool
from google.adk.events import Event, EventActions
from google.adk.runners import InMemoryRunner
from google.genai.types import Content, Part
# Decorator workaround
def tool(func):
    return FunctionTool(func)
# These tools update the 'Internal Context' (session.state) directly.

@tool
def web_surfer_tool(query: str, tool_context: ToolContext) -> str:
    """Simulates researching a topic on the web."""
    print(f"\n[Web Surfer] Searching for: {query}")
    
    # In a real app, you would call Google Search API here
    mock_result = f"Facts about {query}: It involves psychological triggers X and Y."
    
    # WRITE to Internal Context
    if "research" not in tool_context.session.state:
        tool_context.session.state["research"] = []
    tool_context.session.state["research"].append(mock_result)
    
    return "Internal context updated with research."

@tool
def clarifier_tool(tool_context: ToolContext) -> str:
    """Analyzes the conversation and generates internal options."""
    print("\n[Clarifier] Generating options based on context...")
    
    # Simulating logic to generate options
    options = ["Option A: Deep Breathing", "Option B: Reframing Thought"]
    
    # WRITE to Internal Context
    tool_context.session.state["options"] = options
    
    return "Internal context updated with options."


# --- 2. THE LOOP AGENT (The Logic Gate) ---
# This is a Custom Agent that implements your 3-step logic flow.

class LoopRouterAgent(BaseAgent):
    asker_agent: BaseAgent

    def __init__(self, asker_agent: BaseAgent, name: str = "loop_router"):
        super().__init__(name=name, asker_agent=asker_agent)

    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        history = ctx.session.events
        state = ctx.session.state
        
        # Ensure state keys exist for Asker instruction interpolation
        if "research" not in state:
            state["research"] = []
        if "options" not in state:
            state["options"] = []

        # --- LOGIC STEP 1: Has the enquiry ended / fear calculated? ---
        # We check if we have enough internal research data
        if "research" not in state or not state["research"]:
            print(">> Loop Check 1: Need more info. Calling Asker to get user input...")
            # We haven't started deep processing, so let the Asker talk to the user
            async for event in self.asker_agent.run_async(ctx):
                yield event
            return

        # --- LOGIC STEP 2: Understanding Check ---
        # We assume the Asker has explained fear/desire. 
        # In a real app, use an LLM call here to classify the user's last message.
        user_understands = state.get("user_understood_fear", False)
        
        if not user_understands:
            print(">> Loop Check 2: User needs to understand Fear=Desire.")
            # Update instruction dynamically for the Asker
            ctx.run_config.instruction = (
                "Explain to the user that their fear is actually a sign of desire. "
                "Make them feel better."
            )
            async for event in self.asker_agent.run_async(ctx):
                yield event
            
            # For simulation purposes, mark as understood after one explanation
            state["user_understood_fear"] = True 
            return

        # --- LOGIC STEP 3: Feedback/Detachment Check ---
        user_detached = state.get("user_detached", False)
        
        if not user_detached:
            print(">> Loop Check 3: Helping user detach emotion.")
            ctx.run_config.instruction = (
                "Ask the user if they can see the action separately from the emotion. "
                "Provide the options generated by the Clarifier."
            )
            async for event in self.asker_agent.run_async(ctx):
                yield event
            
            state["user_detached"] = True
            return

        # --- END STATE ---
        print(">> All Checks Passed. Ending Conversation.")
        yield Event(
            author=self.name,
            content=Content(parts=[Part(text="Thank you. You seem calm and detached now. The session is complete.")])
        )


# --- 3. MAIN EXECUTION ---

async def main():
    # A. Setup the Model
    # Replace 'gemini-1.5-pro' with your actual model version
    model_client = Gemini(model="gemini-2.5-flash")

    # B. Define the ASKER Agent (The Interface)
    # It has access to the tools to populate internal context if needed, 
    # but primarily relies on the Loop Agent to guide it.
    asker = LlmAgent(
        name="Asker",
        model=model_client,
        instruction=(
            "You are a calm, empathetic assistant. "
            "Use the information in {research} and {options} to guide the user. "
            "Keep your answers short and soothing."
        ),
        tools=[web_surfer_tool, clarifier_tool]
    )

    # C. Define the LOOP Agent
    # It wraps the Asker and controls the flow
    loop_agent = LoopRouterAgent(asker_agent=asker)

    # D. Run the System
    runner = InMemoryRunner(agent=loop_agent)
    
    # Create session
    session = await runner.session_service.create_session(
        app_name=runner.app_name,
        user_id="user_001"
    )
    session_id = session.id

    print("--- STARTING CHAT SYSTEM ---")
    
    # Mocking a conversation flow
    user_inputs = [
        "I am feeling very anxious about my public speaking tomorrow.",
        "I understand that fear means I care about it, but it's still scary.",
        "Yes, I can see the speech is just an action, separate from my fear."
    ]

    for user_text in user_inputs:
        print(f"\nUSER: {user_text}")
        
        # The runner sends the input to the LoopAgent (root), which decides what to do
        async for event in runner.run_async(
            session_id=session_id, 
            user_id="user_001",
            new_message=Content(parts=[Part(text=user_text)])
        ):
            # We only print the final text response to the user
            if event.content and event.author == "Asker":
                print(f"AGENT ({event.author}): {event.content.parts[0].text}")
            elif event.author == "loop_router" and event.content:
                print(f"SYSTEM: {event.content.parts[0].text}")

if __name__ == "__main__":
    asyncio.run(main())